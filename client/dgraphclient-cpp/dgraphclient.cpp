#include <iostream>
#include <memory>
#include <string>

#include <grpc++/grpc++.h>

#include "graphresponse.grpc.pb.h"

using grpc::Channel;
using grpc::ClientContext;
using grpc::Status;
using graph::Request;
using graph::Dgraph;
using graph::Property;

// Extend graph::Response so that we can add a to_string() function
// Why not edit the graph::Response class itself?  Because it is declared
// in a file which is automatically generated by protoc.

class Response : public graph::Response {
  public:
    Response() : graph::Response() {};
    Response(const Response& from) : graph::Response(dynamic_cast<const graph::Response&>(from)) {};
    std::string to_string(void);
    std::string to_string(const graph::Node& n);
};

std::string Response::to_string(const graph::Node& n) {

    // uid and attribute fields
    std::string s = "{ uid:" + std::to_string(n.uid()) +
                    "; attribute:" + n.attribute();

    // zero or more properties, each which may or may not have a value
    s += "; properties:{";
    for (int i = 0; i < n.properties_size(); i++) {
        if (i) s += ", ";
        const Property& p = n.properties(i);
        s += "\"" + p.prop() + "\"";
        if (p.val().length() > 0) {
            s += ":\"" + p.val() + "\"";
        }
    }
    s += "}";

    // And now recursively descend, traversing zero or more child nodes
    for (int i = 0; i < n.children_size(); i++)
        s += to_string(n.children(i));

    // All done
    s += "}";

    return s;
}

std::string Response::to_string(void) {
    if (! this->has_n())
        return "Empty response";
    return to_string(this->n());
}

class GraphClient {
  public:
    GraphClient(std::shared_ptr<Channel> channel)
        : stub_(Dgraph::NewStub(channel)) {}

    // Assembles the client's payload, sends it and presents the response back
    // from the server.
    std::string Query(const std::string& q) {
        // Data we are sending to the server
        Request request;
        request.set_query(q);

        // Container for the data we expect from the server.
        Response reply;

        // Context for the client. It could be used to convey extra information to
        // the server and/or tweak certain RPC behaviors.
        ClientContext context;

        // The actual RPC.
        Status status = stub_->Query(&context, request, &reply);

        // Act upon its status.
        if (status.ok()) {
            return reply.to_string();
        } else {
            return "RPC failed";
        }
    }

  private:
    std::unique_ptr<Dgraph::Stub> stub_;
};

int main(int argc, char** argv) {
    // Instantiate the client. It requires a channel, out of which the actual RPCs
    // are created. This channel models a connection to an endpoint (in this case,
    // localhost at port 8081). We indicate that the channel isn't authenticated
    // (use of InsecureChannelCredentials()).
    GraphClient g(grpc::CreateChannel(
                      "localhost:8081", grpc::InsecureChannelCredentials()));

    // A query intended for the freebase film data
    std::string q(
        "{\n" \
        "  me(_xid_: m.06pj8) {\n" \
        "    type.object.name.en\n" \
        "    film.director.film {\n" \
        "      film.film.starring {\n" \
        "        type.object.name.en\n" \
        "        film.performance.actor {\n" \
        "          film.director.film {\n" \
        "            type.object.name.en\n" \
        "          }\n" \
        "          type.object.name.en\n" \
        "        }\n" \
        "        film.performance.character {\n" \
        "          type.object.name.en\n" \
        "        }\n" \
        "      }\n" \
        "      film.film.initial_release_date\n" \
        "      film.film.country\n" \
        "      film.film.genre {\n" \
        "        type.object.name.en\n" \
        "      }\n" \
        "    }\n" \
        "  }\n" \
        "}\n");
    std::string reply = g.Query(q);
    std::cout << "Response: " << reply << std::endl;
    return 0;
}
